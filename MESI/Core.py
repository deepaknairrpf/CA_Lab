from Automata import *

"""
	Physical address generated by processor is as:
	--------------------------------------------------
	|20-bit Tag| 6-bit Set | 4-bit Word | 2-bit Byte |
	--------------------------------------------------

	16KB capacity, 64B block size, 4B word size & 4 associativity.
"""

class Block:
	def __init__(self, state):
		self._state = state;
		self._lfu = 1000;

	def setState(self, state):
		self._state = state;

	def getState(self):
		return self._state;

	def getLFU(self):
		return self._lfu;

	def decrLFU(self):
		self._lfu =- 1;

class SetBlock:
	def __init__(self):
		self._tagMem  = {};
		self._dataMem = {};

	def set(self, s, t, state):
		if(self._tagMem.has_key(s)): 
			self._tagMem[s] = t;
			del self._dataMem[s];
			self._dataMem[s] = Block(state);
			return True;
		elif(len(self._tagMem.keys()) < 64):
			self._tagMem[s] = t;
			self._dataMem[s] = Block(state);
			return True;		
		return False;

	def setState(self, s, t, state):
		if(self._tagMem.has_key(s) and self._tagMem[s]==t):
			print "<%s, %s> %s -> %s"%(s, t, self._dataMem[s].getState(), state);
			self._dataMem[s].setState(state);

	def get(self, s, t):
		if(self._tagMem.has_key(s) and self._tagMem[s]==t):
			return [self._dataMem[s].getState()];
		return [];

	def getLFU(self, s):
		if(self._tagMem.has_key(s)):
			return self._dataMem[s].getLFU();
		return -1;

	def decrLFU(self, s, t):
		if(self._tagMem.has_key(s) and self._tagMem[s]==t):
			self._dataMem[s].decrLFU();

class Cache:
	def __init__(self):
		self._block0 = SetBlock();
		self._block1	 = SetBlock();
		self._block2 = SetBlock();
		self._block3 = SetBlock();

	def getState(self, s, t):
		state = self._block0.get(s, t);
		if(len(state)==1):
			self._block0.decrLFU(s, t);
			return state;
		state = self._block1.get(s, t);
		if(len(state)==1):
			self._block1.decrLFU(s, t);
			return state;
		state = self._block2.get(s, t);
		if(len(state)==1):
			self._block2.decrLFU(s, t);
			return state;
		state = self._block3.get(s, t);
		if(len(state)==1):
			self._block3.decrLFU(s, t);
			return state;
		return [];

	def setState(self, s, t, nState):		
		state = self._block0.get(s, t);
		if(len(state)==1):
			self._block0.set(s, t, nState);
			return;
		state = self._block1.get(s, t);
		if(len(state)==1):
			self._block1.set(s, t, nState);
			return;
		state = self._block2.get(s, t);
		if(len(state)==1):
			self._block2.set(s, t, nState);
			return;
		state = self._block3.get(s, t);
		if(len(state)==1):
			self._block3.set(s, t, nState);
			return;
		idLFU = self.__idLFU(s);
		if(idLFU==0):
			self._block0.set(s, t, nState);
		elif(idLFU==1):
			self._block1.set(s, t, nState);
		elif(idLFU==2):
			self._block2.set(s, t, nState);
		else:
			self._block3.set(s, t, nState);

	def changeState(self, s, t, nState):
		state = self._block0.get(s, t);
		if(len(state)==1):
			self._block0.setState(s, t, nState);
			return;
		state = self._block1.get(s, t);
		if(len(state)==1):
			self._block1.setState(s, t, nState);
			return;
		state = self._block2.get(s, t);
		if(len(state)==1):
			self._block2.setState(s, t, nState);
			return;
		state = self._block3.get(s, t);
		if(len(state)==1):
			self._block3.setState(s, t, nState);

	def __idLFU(self, s):		
		countLFU = [self._block0.getLFU(s)];
		if(countLFU[0]==-1):
			return 0;
		countLFU.append(self._block1.getLFU(s));
		if(countLFU[1]==-1):
			return 1;
		countLFU.append(self._block2.getLFU(s));
		if(countLFU[2]==-1):
			return 2;
		countLFU.append(self._block3.getLFU(s));
		if(countLFU[3]==-1):
			return 3;
		idLFU = 0;
		for i in range(1,4):
			if(countLFU[idLFU] > countLFU[i]):
				idLFU = i;
		return idLFU;

class Core:
	def __init__(self):
		self._cache	= Cache();	
		self._automata = Automata();

		self._coherenceMisses = 0;
		self._cacheMisses = 0;

	def printStats(self, name):
		print "Core %s:"%name
		print "\tCache Misses:", self._cacheMisses
		print "\tCoherence Misses:", self._coherenceMisses

	def read(self, s, t):
		state = self._cache.getState(s, t);
		# cache hit
		if(len(state)==1 and state[0]!='I'):
			return [];
		# cacheBlock in Invalid state
		elif(len(state)==1 and state[0]=='I'):
			self._coherenceMisses = self._coherenceMisses + 1;
			return ['BR','I'];
		# cache miss
		else:
			self._cacheMisses = self._cacheMisses + 1;
			return ['BR'];

	def write(self, s, t):
		state = self._cache.getState(s, t);
		if(len(state)==0):
			self._cacheMisses = self._cacheMisses + 1
			self._cache.setState(s, t, 'M');
		else:
			if state[0]=='I':
				self._coherenceMisses = self._coherenceMisses + 1
			self._cache.changeState(s, t, 'M');
		return ['BX'];

	def request(self, s, t, request):
		state = self._cache.getState(s, t);
		if(len(state)==0):
			return []
		mesiTxn = self._automata.get(state[0],request);
		if request=='BR' and len(mesiTxn) !=0 :
			self._cache.changeState(s, t, mesiTxn[0]);
			return state;
		elif request=='BX' and len(mesiTxn)!=0:
			self._cache.changeState(s, t, mesiTxn[0]);
			return [];
		return [];

	def new(self, s, t, state):
		self._cache.setState(s, t, state);

	def change(self, s, t,state):
		self._cache.changeState(s, t, state);
